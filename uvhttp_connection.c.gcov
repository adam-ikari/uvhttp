        -:    0:Source:/home/zhaodi-chen/project/uvhttp/src/uvhttp_connection.c
        -:    0:Graph:build/CMakeFiles/uvhttp.dir/src/uvhttp_connection.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:#include "uvhttp_connection.h"
        -:    2:#include "uvhttp_utils.h"
        -:    3:#include "uvhttp_request_simple.h"
        -:    4:#include "uvhttp_response_simple.h"
        -:    5:#include "uvhttp_server_simple.h"
        -:    6:#include <stdlib.h>
        -:    7:#include <string.h>
        -:    8:#include <stdio.h>
        -:    9:
        -:   10:static const char* state_strings[] = {
        -:   11:    "NEW",
        -:   12:    "TLS_HANDSHAKE", 
        -:   13:    "HTTP_READING",
        -:   14:    "HTTP_PROCESSING",
        -:   15:    "HTTP_WRITING",
        -:   16:    "CLOSING"
        -:   17:};
        -:   18:
        -:   19:// 单线程并发实现 - 使用全局变量（libuv是单线程事件循环）
        -:   20:static uvhttp_connection_t* current_connection = NULL;
        -:   21:
        -:   22:// HTTP解析器回调函数
    #####:   23:static int on_message_begin(llhttp_t* parser) {
        -:   24:    (void)parser; // 避免未使用参数警告
    #####:   25:    uvhttp_connection_t* conn = current_connection;
    #####:   26:    if (!conn || !conn->request) {
    #####:   27:        return -1;
        -:   28:    }
        -:   29:    
    #####:   30:    conn->parsing_complete = 0;
    #####:   31:    conn->content_length = 0;
    #####:   32:    conn->body_received = 0;
        -:   33:    
    #####:   34:    return 0;
        -:   35:}
        -:   36:
    #####:   37:static int on_url(llhttp_t* parser, const char* at, size_t length) {
        -:   38:    (void)parser; // 避免未使用参数警告
    #####:   39:    uvhttp_connection_t* conn = current_connection;
    #####:   40:    if (!conn || !conn->request) {
    #####:   41:        return -1;
        -:   42:    }
        -:   43:    
        -:   44:    // 验证URL长度
    #####:   45:    if (length > 2048) {
    #####:   46:        return -1;
        -:   47:    }
        -:   48:    
        -:   49:    // 复制URL到请求对象
    #####:   50:    if (conn->request->url) {
    #####:   51:        free(conn->request->url);
        -:   52:    }
    #####:   53:    conn->request->url = malloc(length + 1);
    #####:   54:    if (!conn->request->url) {
    #####:   55:        return -1;
        -:   56:    }
        -:   57:    
    #####:   58:    memcpy(conn->request->url, at, length);
    #####:   59:    conn->request->url[length] = '\0';
        -:   60:    
    #####:   61:    return 0;
        -:   62:}
        -:   63:
    #####:   64:static int on_header_field(llhttp_t* parser, const char* at, size_t length) {
        -:   65:    (void)parser; // 避免未使用参数警告
    #####:   66:    uvhttp_connection_t* conn = current_connection;
    #####:   67:    if (!conn || !conn->request) {
    #####:   68:        return -1;
        -:   69:    }
        -:   70:    
        -:   71:    // 检查header数量限制
    #####:   72:    if (conn->request->header_count >= MAX_HEADERS) {
    #####:   73:        return -1;
        -:   74:    }
        -:   75:    
    #####:   76:    uvhttp_header_t* header = &conn->request->headers[conn->request->header_count];
        -:   77:    
        -:   78:    // 复制header名称
    #####:   79:    if (uvhttp_safe_strcpy(header->name, sizeof(header->name), "") != 0) {
    #####:   80:        return -1;
        -:   81:    }
        -:   82:    
    #####:   83:    size_t copy_len = length < sizeof(header->name) - 1 ? length : sizeof(header->name) - 1;
    #####:   84:    memcpy(header->name, at, copy_len);
    #####:   85:    header->name[copy_len] = '\0';
        -:   86:    
    #####:   87:    return 0;
        -:   88:}
        -:   89:
    #####:   90:static int on_header_value(llhttp_t* parser, const char* at, size_t length) {
        -:   91:    (void)parser; // 避免未使用参数警告
    #####:   92:    uvhttp_connection_t* conn = current_connection;
    #####:   93:    if (!conn || !conn->request) {
    #####:   94:        return -1;
        -:   95:    }
        -:   96:    
    #####:   97:    uvhttp_header_t* header = &conn->request->headers[conn->request->header_count];
        -:   98:    
        -:   99:    // 复制header值
    #####:  100:    if (uvhttp_safe_strcpy(header->value, sizeof(header->value), "") != 0) {
    #####:  101:        return -1;
        -:  102:    }
        -:  103:    
    #####:  104:    size_t copy_len = length < sizeof(header->value) - 1 ? length : sizeof(header->value) - 1;
    #####:  105:    memcpy(header->value, at, copy_len);
    #####:  106:    header->value[copy_len] = '\0';
        -:  107:    
        -:  108:    // 验证header
    #####:  109:    if (uvhttp_validate_header_value(header->name, header->value) != 0) {
    #####:  110:        return -1;
        -:  111:    }
        -:  112:    
    #####:  113:    conn->request->header_count++;
    #####:  114:    return 0;
        -:  115:}
        -:  116:
    #####:  117:static int on_body(llhttp_t* parser, const char* at, size_t length) {
        -:  118:    (void)parser; // 避免未使用参数警告
    #####:  119:    uvhttp_connection_t* conn = current_connection;
    #####:  120:    if (!conn || !conn->request) {
    #####:  121:        return -1;
        -:  122:    }
        -:  123:    
        -:  124:    // 检查body大小限制（1MB）
    #####:  125:    if (conn->body_received + length > 1024 * 1024) {
    #####:  126:        return -1;
        -:  127:    }
        -:  128:    
        -:  129:    // 重新分配内存以容纳body
    #####:  130:    char* new_body = realloc(conn->request->body, conn->body_received + length);
    #####:  131:    if (!new_body) {
    #####:  132:        return -1;
        -:  133:    }
        -:  134:    
    #####:  135:    conn->request->body = new_body;
    #####:  136:    memcpy(conn->request->body + conn->body_received, at, length);
    #####:  137:    conn->body_received += length;
    #####:  138:    conn->request->body_length = conn->body_received;
        -:  139:    
    #####:  140:    return 0;
        -:  141:}
        -:  142:
    #####:  143:static int on_message_complete(llhttp_t* parser) {
    #####:  144:    uvhttp_connection_t* conn = current_connection;
    #####:  145:    if (!conn || !conn->request) {
    #####:  146:        return -1;
        -:  147:    }
        -:  148:    
        -:  149:    // 设置HTTP方法
    #####:  150:    conn->request->method = (int)llhttp_get_method(parser);
        -:  151:    
        -:  152:    // 标记解析完成
    #####:  153:    conn->parsing_complete = 1;
        -:  154:    
    #####:  155:    return 0;
        -:  156:}
        -:  157:
        -:  158:// 初始化HTTP解析器
    #####:  159:static int init_http_parser(uvhttp_connection_t* conn) {
    #####:  160:    if (!conn) {
    #####:  161:        return -1;
        -:  162:    }
        -:  163:    
        -:  164:    // 分配解析器设置
    #####:  165:    conn->parser_settings = malloc(sizeof(llhttp_settings_t));
    #####:  166:    if (!conn->parser_settings) {
    #####:  167:        return -1;
        -:  168:    }
        -:  169:    
    #####:  170:    llhttp_settings_init(conn->parser_settings);
        -:  171:    
        -:  172:    // 设置回调函数 - 使用正确的llhttp API
    #####:  173:    conn->parser_settings->on_message_begin = on_message_begin;
    #####:  174:    conn->parser_settings->on_url = on_url;
    #####:  175:    conn->parser_settings->on_header_field = on_header_field;
    #####:  176:    conn->parser_settings->on_header_value = on_header_value;
    #####:  177:    conn->parser_settings->on_body = on_body;
    #####:  178:    conn->parser_settings->on_message_complete = on_message_complete;
        -:  179:    
        -:  180:    // 分配解析器
    #####:  181:    conn->http_parser = calloc(1, 100); // 简化版本使用固定大小
    #####:  182:    if (!conn->http_parser) {
    #####:  183:        free(conn->parser_settings);
    #####:  184:        conn->parser_settings = NULL;
    #####:  185:        return -1;
        -:  186:    }
        -:  187:    
    #####:  188:    llhttp_init(conn->http_parser, HTTP_REQUEST, conn->parser_settings);
        -:  189:    
    #####:  190:    return 0;
        -:  191:}
        -:  192:
        -:  193:static void on_close(void* handle);
        -:  194:
    #####:  195:uvhttp_connection_t* uvhttp_connection_new(struct uvhttp_server* server) {
    #####:  196:    if (!server) {
    #####:  197:        return NULL;
        -:  198:    }
        -:  199:    
    #####:  200:    uvhttp_connection_t* conn = malloc(sizeof(uvhttp_connection_t));
    #####:  201:    if (!conn) {
    #####:  202:        return NULL;
        -:  203:    }
        -:  204:    
    #####:  205:    memset(conn, 0, sizeof(uvhttp_connection_t));
        -:  206:    
    #####:  207:    conn->server = server;
    #####:  208:    conn->state = UVHTTP_CONN_STATE_NEW;
    #####:  209:    conn->tls_enabled = 0; // 简化版本暂时禁用TLS
        -:  210:    
        -:  211:    // 简化版本跳过TCP初始化
        -:  212:    
        -:  213:    // 分配读缓冲区
    #####:  214:    conn->read_buffer_size = 8192;
    #####:  215:    conn->read_buffer = malloc(conn->read_buffer_size);
    #####:  216:    if (!conn->read_buffer) {
    #####:  217:        free(conn);
    #####:  218:        return NULL;
        -:  219:    }
        -:  220:    
        -:  221:    // 初始化HTTP解析器
    #####:  222:    if (init_http_parser(conn) != 0) {
    #####:  223:        free(conn->read_buffer);
    #####:  224:        free(conn);
    #####:  225:        return NULL;
        -:  226:    }
        -:  227:    
        -:  228:    // 创建请求和响应对象
    #####:  229:    conn->request = malloc(sizeof(uvhttp_request_t));
    #####:  230:    if (!conn->request) {
    #####:  231:        free(conn->http_parser);
    #####:  232:        free(conn->parser_settings);
    #####:  233:        free(conn->read_buffer);
    #####:  234:        free(conn);
    #####:  235:        return NULL;
        -:  236:    }
        -:  237:    
    #####:  238:    memset(conn->request, 0, sizeof(uvhttp_request_t));
        -:  239:    
    #####:  240:    conn->response = malloc(sizeof(uvhttp_response_t));
    #####:  241:    if (!conn->response) {
    #####:  242:        free(conn->request);
    #####:  243:        free(conn->http_parser);
    #####:  244:        free(conn->parser_settings);
    #####:  245:        free(conn->read_buffer);
    #####:  246:        free(conn);
    #####:  247:        return NULL;
        -:  248:    }
        -:  249:    
    #####:  250:    memset(conn->response, 0, sizeof(uvhttp_response_t));
        -:  251:    
    #####:  252:    return conn;
        -:  253:}
        -:  254:
    #####:  255:void uvhttp_connection_free(uvhttp_connection_t* conn) {
    #####:  256:    if (!conn) {
    #####:  257:        return;
        -:  258:    }
        -:  259:    
    #####:  260:    if (conn->request) {
    #####:  261:        uvhttp_request_cleanup(conn->request);
    #####:  262:        free(conn->request);
        -:  263:    }
        -:  264:    
    #####:  265:    if (conn->response) {
    #####:  266:        uvhttp_response_cleanup(conn->response);
    #####:  267:        free(conn->response);
        -:  268:    }
        -:  269:    
    #####:  270:    if (conn->http_parser) {
    #####:  271:        free(conn->http_parser);
        -:  272:    }
        -:  273:    
    #####:  274:    if (conn->parser_settings) {
    #####:  275:        free(conn->parser_settings);
        -:  276:    }
        -:  277:    
    #####:  278:    if (conn->read_buffer) {
    #####:  279:        free(conn->read_buffer);
        -:  280:    }
        -:  281:    
    #####:  282:    free(conn);
        -:  283:}
        -:  284:
    #####:  285:int uvhttp_connection_start(uvhttp_connection_t* conn) {
    #####:  286:    if (!conn) {
    #####:  287:        return -1;
        -:  288:    }
        -:  289:    
        -:  290:    // 简化版本直接开始HTTP读取
    #####:  291:    uvhttp_connection_set_state(conn, UVHTTP_CONN_STATE_HTTP_READING);
    #####:  292:    return 0; // 成功
        -:  293:}
        -:  294:
    #####:  295:int uvhttp_connection_start_tls_handshake(uvhttp_connection_t* conn) {
        -:  296:    // 简化版本不支持TLS
        -:  297:    (void)conn;
    #####:  298:    return -1;
        -:  299:}
        -:  300:
        -:  301:
        -:  302:
    #####:  303:int uvhttp_connection_tls_write(uvhttp_connection_t* conn, const void* data, size_t len) {
        -:  304:    // 简化版本不支持TLS
        -:  305:    (void)conn;
        -:  306:    (void)data;
        -:  307:    (void)len;
    #####:  308:    return -1;
        -:  309:}
        -:  310:
    #####:  311:void uvhttp_connection_close(uvhttp_connection_t* conn) {
    #####:  312:    if (!conn) {
    #####:  313:        return;
        -:  314:    }
        -:  315:    
    #####:  316:    uvhttp_connection_set_state(conn, UVHTTP_CONN_STATE_CLOSING);
        -:  317:    
        -:  318:    // 简化版本直接调用关闭回调
    #####:  319:    on_close(conn);
        -:  320:}
        -:  321:
    #####:  322:void uvhttp_connection_set_state(uvhttp_connection_t* conn, uvhttp_connection_state_t state) {
    #####:  323:    if (conn) {
    #####:  324:        conn->state = state;
        -:  325:    }
    #####:  326:}
        -:  327:
    #####:  328:const char* uvhttp_connection_get_state_string(uvhttp_connection_state_t state) {
    #####:  329:    if (state >= 0 && state < sizeof(state_strings) / sizeof(state_strings[0])) {
    #####:  330:        return state_strings[state];
        -:  331:    }
    #####:  332:    return "UNKNOWN";
        -:  333:}
        -:  334:
        -:  335:
        -:  336:
        -:  337:
        -:  338:
    #####:  339:static void on_close(void* handle) {
    #####:  340:    uvhttp_connection_t* conn = (uvhttp_connection_t*)handle;
    #####:  341:    if (conn) {
    #####:  342:        if (conn->server) {
    #####:  343:            conn->server->active_connections--;
        -:  344:        }
    #####:  345:        uvhttp_connection_free(conn);
        -:  346:    }
    #####:  347:}
