.TH "include/uvhttp_async_file.h" 3 "Fri Jan 23 2026" "Version 2.0.0" "UVHTTP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/uvhttp_async_file.h
.SH SYNOPSIS
.br
.PP
\fC#include <uv\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include 'uvhttp_constants\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBuvhttp_async_file_request\fP"
.br
.ti -1c
.RI "struct \fBuvhttp_async_file_manager\fP"
.br
.ti -1c
.RI "struct \fBuvhttp_file_stream_context\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBuvhttp_async_file_request\fP \fBuvhttp_async_file_request_t\fP"
.br
.ti -1c
.RI "typedef struct \fBuvhttp_async_file_manager\fP \fBuvhttp_async_file_manager_t\fP"
.br
.ti -1c
.RI "typedef struct \fBuvhttp_file_stream_context\fP \fBuvhttp_file_stream_context_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBuvhttp_async_file_state_t\fP { \fBUVHTTP_ASYNC_FILE_STATE_PENDING\fP, \fBUVHTTP_ASYNC_FILE_STATE_READING\fP, \fBUVHTTP_ASYNC_FILE_STATE_COMPLETED\fP, \fBUVHTTP_ASYNC_FILE_STATE_ERROR\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBuvhttp_async_file_manager_t\fP * \fBuvhttp_async_file_manager_create\fP (uv_loop_t *loop, int max_concurrent, size_t buffer_size, size_t max_file_size)"
.br
.ti -1c
.RI "void \fBuvhttp_async_file_manager_free\fP (\fBuvhttp_async_file_manager_t\fP *manager)"
.br
.ti -1c
.RI "int \fBuvhttp_async_file_read\fP (\fBuvhttp_async_file_manager_t\fP *manager, const char *file_path, void *request, void *response, void *static_context, void(*completion_cb)(\fBuvhttp_async_file_request_t\fP *req, int status))"
.br
.ti -1c
.RI "int \fBuvhttp_async_file_cancel\fP (\fBuvhttp_async_file_manager_t\fP *manager, \fBuvhttp_async_file_request_t\fP *req)"
.br
.ti -1c
.RI "int \fBuvhttp_async_file_stream\fP (\fBuvhttp_async_file_manager_t\fP *manager, const char *file_path, void *response, size_t chunk_size)"
.br
.ti -1c
.RI "int \fBuvhttp_async_file_stream_stop\fP (\fBuvhttp_file_stream_context_t\fP *stream_ctx)"
.br
.ti -1c
.RI "int \fBuvhttp_async_file_get_stats\fP (\fBuvhttp_async_file_manager_t\fP *manager, int *current_reads, int *max_concurrent)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBuvhttp_async_file_manager\fP \fBuvhttp_async_file_manager_t\fP"

.SS "typedef struct \fBuvhttp_async_file_request\fP \fBuvhttp_async_file_request_t\fP"

.SS "typedef struct \fBuvhttp_file_stream_context\fP \fBuvhttp_file_stream_context_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBuvhttp_async_file_state_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUVHTTP_ASYNC_FILE_STATE_PENDING \fP\fP
.TP
\fB\fIUVHTTP_ASYNC_FILE_STATE_READING \fP\fP
.TP
\fB\fIUVHTTP_ASYNC_FILE_STATE_COMPLETED \fP\fP
.TP
\fB\fIUVHTTP_ASYNC_FILE_STATE_ERROR \fP\fP
.SH "Function Documentation"
.PP 
.SS "int uvhttp_async_file_cancel (\fBuvhttp_async_file_manager_t\fP * manager, \fBuvhttp_async_file_request_t\fP * req)"
取消异步文件读取
.PP
\fBParameters\fP
.RS 4
\fImanager\fP 管理器 
.br
\fIreq\fP 读取请求 
.RE
.PP
\fBReturns\fP
.RS 4
0成功，-1失败
.RE
.PP
取消异步文件读取 
.SS "int uvhttp_async_file_get_stats (\fBuvhttp_async_file_manager_t\fP * manager, int * current_reads, int * max_concurrent)"
获取管理器统计信息
.PP
\fBParameters\fP
.RS 4
\fImanager\fP 管理器 
.br
\fIcurrent_reads\fP 输出当前读取数 
.br
\fImax_concurrent\fP 输出最大并发数 
.RE
.PP
\fBReturns\fP
.RS 4
0成功，-1失败
.RE
.PP
获取管理器统计信息 
.SS "\fBuvhttp_async_file_manager_t\fP* uvhttp_async_file_manager_create (uv_loop_t * loop, int max_concurrent, size_t buffer_size, size_t max_file_size)"
创建异步文件读取管理器
.PP
\fBParameters\fP
.RS 4
\fIloop\fP 事件循环 
.br
\fImax_concurrent\fP 最大并发读取数 
.br
\fIbuffer_size\fP 读取缓冲区大小 
.br
\fImax_file_size\fP 最大文件大小 
.RE
.PP
\fBReturns\fP
.RS 4
管理器指针，失败返回NULL
.RE
.PP
创建异步文件读取管理器 
.SS "void uvhttp_async_file_manager_free (\fBuvhttp_async_file_manager_t\fP * manager)"
释放异步文件读取管理器
.PP
\fBParameters\fP
.RS 4
\fImanager\fP 管理器指针
.RE
.PP
释放异步文件读取管理器 
.SS "int uvhttp_async_file_read (\fBuvhttp_async_file_manager_t\fP * manager, const char * file_path, void * request, void * response, void * static_context, void(*)(\fBuvhttp_async_file_request_t\fP *req, int status) completion_cb)"
异步读取文件
.PP
\fBParameters\fP
.RS 4
\fImanager\fP 管理器 
.br
\fIfile_path\fP 文件路径 
.br
\fIrequest\fP HTTP请求对象 
.br
\fIresponse\fP HTTP响应对象 
.br
\fIstatic_context\fP 静态文件上下文 
.br
\fIcompletion_cb\fP 完成回调 
.RE
.PP
\fBReturns\fP
.RS 4
0成功，-1失败
.RE
.PP
异步读取文件 
.SS "int uvhttp_async_file_stream (\fBuvhttp_async_file_manager_t\fP * manager, const char * file_path, void * response, size_t chunk_size)"
流式传输文件（适用于大文件）
.PP
\fBParameters\fP
.RS 4
\fImanager\fP 管理器 
.br
\fIfile_path\fP 文件路径 
.br
\fIresponse\fP HTTP响应对象 
.br
\fIchunk_size\fP 分块大小 
.RE
.PP
\fBReturns\fP
.RS 4
0成功，-1失败
.RE
.PP
流式传输文件（适用于大文件） 
.SS "int uvhttp_async_file_stream_stop (\fBuvhttp_file_stream_context_t\fP * stream_ctx)"
停止文件流传输
.PP
\fBParameters\fP
.RS 4
\fIstream_ctx\fP 流传输上下文 
.RE
.PP
\fBReturns\fP
.RS 4
0成功，-1失败
.RE
.PP
停止文件流传输 
.SH "Author"
.PP 
Generated automatically by Doxygen for UVHTTP from the source code\&.
