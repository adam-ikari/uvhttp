name: Nightly Build

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      run-performance:
        description: 'Run performance tests'
        required: false
        default: 'true'
        type: boolean
      run-coverage:
        description: 'Run coverage tests'
        required: false
        default: 'true'
        type: boolean

concurrency:
  group: nightly-build
  cancel-in-progress: false

env:
  TIMEOUT_MINUTES: 60
  CACHE_VERSION: v1

jobs:
  # 完整测试套件 - 运行所有测试（fast + slow）
  full-test-suite:
    runs-on: ubuntu-22.04
    timeout-minutes: ${{ env.TIMEOUT_MINUTES }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Cache apt packages
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: cmake build-essential
        version: ubuntu-22.04

    - name: Cache ccache
      uses: actions/cache@v3
      with:
        path: ~/.ccache
        key: ${{ runner.os }}-ccache-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-ccache-

    - name: Cache CMake build
      uses: actions/cache@v3
      with:
        path: |
          build
          build-*
        key: ${{ runner.os }}-cmake-${{ env.CACHE_VERSION }}-${{ hashFiles('**/CMakeLists.txt', '**/*.c', '**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-cmake-${{ env.CACHE_VERSION }}-

    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_EXAMPLES=ON

    - name: Build
      run: |
        cmake --build build --config Release -j$(nproc)

    - name: Run fast tests
      run: |
        cd build
        start_time=$(date +%s)
        ctest --output-on-failure -j$(nproc) --timeout 60 \
          --label-regex "^fast$" --schedule-random || {
          echo "Fast tests failed"
          exit 1
        }
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        echo "Fast tests completed in ${duration} seconds"
        echo "duration=$duration" >> $GITHUB_OUTPUT

    - name: Run slow tests
      run: |
        cd build
        start_time=$(date +%s)
        ctest --output-on-failure -j$(nproc) --timeout 180 \
          --label-regex "^slow$" --schedule-random || {
          echo "Slow tests failed"
          exit 1
        }
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        echo "Slow tests completed in ${duration} seconds"
        echo "duration=$duration" >> $GITHUB_OUTPUT

  # 性能测试 - 运行性能基准测试
  performance-test:
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    if: github.event.inputs.run-performance != 'false'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Cache apt packages
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: cmake build-essential wrk
        version: ubuntu-22.04

    - name: Cache CMake build
      uses: actions/cache@v3
      with:
        path: |
          build
          build-*
        key: ${{ runner.os }}-cmake-${{ env.CACHE_VERSION }}-${{ hashFiles('**/CMakeLists.txt', '**/*.c', '**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-cmake-${{ env.CACHE_VERSION }}-

    - name: Build project with examples
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_EXAMPLES=ON
        cmake --build build --config Release -j$(nproc)

    - name: Run performance tests
      id: performance
      run: |
        mkdir -p build/public
        echo "<html><body><h1>Performance Test</h1></body></html>" > build/public/index.html
        echo "Test file content" > build/public/test.txt
        cd build

        if [ -f "./dist/bin/performance_static_server" ]; then
          # 启动服务器
          ./dist/bin/performance_static_server -d ./public -p 8080 &
          SERVER_PID=$!

          # 等待服务器启动，最多等待 15 秒
          TIMEOUT=15
          COUNT=0
          while [ $COUNT -lt $TIMEOUT ]; do
            if curl -s http://localhost:8080/ > /dev/null 2>&1; then
              echo "Server started successfully"
              break
            fi
            sleep 1
            COUNT=$((COUNT + 1))
          done

          if [ $COUNT -eq $TIMEOUT ]; then
            echo "Server failed to start within $TIMEOUT seconds"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi

          # 预热服务器
          echo "Warming up server..."
          wrk -t2 -c10 -d5s http://localhost:8080/ > /dev/null 2>&1 || true
          sleep 2

          # 运行性能测试
          echo "Running performance test..."
          wrk -t4 -c100 -d10s --timeout 5s http://localhost:8080/ > wrk_result.txt
          WRK_EXIT=$?

          # 提取性能指标
          RPS=$(grep "Requests/sec:" wrk_result.txt | awk '{print $2}')
          AVG_LATENCY=$(grep "Latency" wrk_result.txt | head -1 | awk '{print $2}')
          P99_LATENCY=$(grep "99%" wrk_result.txt | awk '{print $2}')

          echo "Performance Results:"
          echo "  RPS: $RPS"
          echo "  Avg Latency: $AVG_LATENCY"
          echo "  P99 Latency: $P99_LATENCY"

          echo "rps=$RPS" >> $GITHUB_OUTPUT
          echo "avg_latency=$AVG_LATENCY" >> $GITHUB_OUTPUT
          echo "p99_latency=$P99_LATENCY" >> $GITHUB_OUTPUT

          # 清理
          kill $SERVER_PID 2>/dev/null || true
          wait $SERVER_PID 2>/dev/null || true

          if [ $WRK_EXIT -ne 0 ]; then
            echo "Performance test failed with exit code: $WRK_EXIT"
            exit 1
          fi
        else
          echo "performance_static_server not found, skipping performance test"
        fi

    - name: Check performance regression
      run: |
        # 定义基准值
        BASELINE_RPS=15000
        BASELINE_P99_MS=50

        # 获取当前值
        CURRENT_RPS=${{ steps.performance.outputs.rps }}
        CURRENT_P99=${{ steps.performance.outputs.p99_latency }}

        # 检查 RPS 是否低于基准的 90%
        RPS_THRESHOLD=$(echo "$BASELINE_RPS * 0.9" | bc)
        if (( $(echo "$CURRENT_RPS < $RPS_THRESHOLD" | bc -l) )); then
          echo "❌ Performance regression detected in RPS!"
          echo "Baseline: $BASELINE_RPS RPS, Threshold: $RPS_THRESHOLD RPS, Current: $CURRENT_RPS RPS"
          exit 1
        fi

        # 检查 P99 延迟是否超过基准的 110%
        P99_THRESHOLD=$(echo "$BASELINE_P99_MS * 1.1" | bc)
        if (( $(echo "$CURRENT_P99 > $P99_THRESHOLD" | bc -l) )); then
          echo "❌ Performance regression detected in P99 latency!"
          echo "Baseline: ${BASELINE_P99_MS}ms, Threshold: ${P99_THRESHOLD}ms, Current: ${CURRENT_P99}ms"
          exit 1
        fi

        echo "✅ Performance check passed!"
        echo "RPS: $CURRENT_RPS (baseline: $BASELINE_RPS)"
        echo "P99: $CURRENT_P99 (baseline: ${BASELINE_P99_MS}ms)"

  # 内存泄漏检查
  memory-leak-check:
    runs-on: ubuntu-22.04
    timeout-minutes: 30

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Cache apt packages
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: cmake build-essential valgrind
        version: ubuntu-22.04

    - name: Cache CMake build
      uses: actions/cache@v3
      with:
        path: |
          build
          build-*
        key: ${{ runner.os }}-cmake-${{ env.CACHE_VERSION }}-${{ hashFiles('**/CMakeLists.txt', '**/*.c', '**/*.h') }}
        restore-keys: |
          ${{ runner.os }}-cmake-${{ env.CACHE_VERSION }}-

    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Debug

    - name: Build
      run: |
        cmake --build build --config Debug -j$(nproc)

    - name: Memory leak check
      run: |
        cd build
        if [ -f "./dist/bin/test_connection_full_coverage" ]; then
          valgrind --leak-check=full --error-exitcode=1 \
            --suppressions=../.github/valgrind.supp \
            ./dist/bin/test_connection_full_coverage || {
            echo "Memory leak detected"
            exit 1
          }
        else
          echo "test_connection_full_coverage not found, skipping valgrind"
        fi